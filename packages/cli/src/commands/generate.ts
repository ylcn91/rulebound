import { writeFileSync, mkdirSync, existsSync } from "node:fs"
import { resolve, dirname } from "node:path"
import chalk from "chalk"
import { findRulesDir, loadLocalRules, matchRulesByContext, type LocalRule } from "../lib/local-rules.js"
import { getProjectConfig } from "../lib/inheritance.js"

interface GenerateOptions {
  dir?: string
  output?: string
  agent?: string
  task?: string
}

type AgentFormat = "claude-code" | "cursor" | "copilot" | "all"

const MODALITY_PREFIX: Record<string, string> = {
  must: "MUST:",
  should: "SHOULD:",
  may: "MAY:",
}

const SEVERITY_INDICATOR: Record<string, string> = {
  error: "[!]",
  warning: "[~]",
  info: "[i]",
}

function extractContent(rule: LocalRule): string {
  const lines: string[] = []

  // Extract bullet points
  const bullets = rule.content.split("\n").filter((l) => l.startsWith("- "))
  for (const bullet of bullets) {
    lines.push(bullet)
  }

  // Extract code blocks (sample code is important for agents)
  const codeBlockRegex = /```[\w]*\n([\s\S]*?)```/g
  const sections = rule.content.split(/\n## /)
  
  for (const section of sections) {
    const sectionLower = section.toLowerCase()
    if (sectionLower.startsWith("good example") || sectionLower.startsWith("correct") || sectionLower.startsWith("recommended")) {
      const codeMatch = section.match(/```[\w]*\n([\s\S]*?)```/)
      if (codeMatch) {
        lines.push("")
        lines.push("Example:")
        lines.push("```")
        lines.push(codeMatch[1].trim())
        lines.push("```")
      }
    }
  }

  if (lines.length === 0) {
    // Fallback: first meaningful paragraph
    const firstPara = rule.content.split("\n\n").find((p) => p.length > 20 && !p.startsWith("#"))
    if (firstPara) lines.push(firstPara.trim())
  }

  return lines.join("\n")
}

function formatRulesForAgent(rules: LocalRule[], agent: string): string {
  const lines: string[] = []
  const timestamp = new Date().toISOString().split("T")[0]

  switch (agent) {
    case "claude-code":
      lines.push("# Project Rules")
      lines.push(`# Generated by Rulebound on ${timestamp}`)
      lines.push(`# Source: .rulebound/rules/ (${rules.length} rules)`)
      lines.push("")
      lines.push("## Engineering Standards")
      lines.push("")
      for (const rule of rules) {
        const prefix = MODALITY_PREFIX[rule.modality] ?? "SHOULD:"
        const sev = SEVERITY_INDICATOR[rule.severity] ?? ""
        lines.push(`### ${prefix} ${rule.title} ${sev}`)
        lines.push("")
        lines.push(extractContent(rule))
        lines.push("")
      }
      lines.push("---")
      lines.push("*Auto-generated by [Rulebound](https://github.com/ylcn91/rulebound). Do not edit manually.*")
      break

    case "cursor":
      lines.push("# Project Rules")
      lines.push(`# Generated by Rulebound on ${timestamp}`)
      lines.push("")
      for (const rule of rules) {
        const prefix = MODALITY_PREFIX[rule.modality] ?? "SHOULD:"
        lines.push(`## ${prefix} ${rule.title}`)
        lines.push("")
        lines.push(extractContent(rule))
        lines.push("")
      }
      break

    case "copilot":
      lines.push("# GitHub Copilot Instructions")
      lines.push(`# Generated by Rulebound on ${timestamp}`)
      lines.push("")
      lines.push("Follow these engineering standards for all code generation:")
      lines.push("")
      for (const rule of rules) {
        const prefix = MODALITY_PREFIX[rule.modality] ?? "SHOULD:"
        lines.push(`## ${prefix} ${rule.title}`)
        lines.push("")
        lines.push(extractContent(rule))
        lines.push("")
      }
      break
  }

  return lines.join("\n") + "\n"
}

const AGENT_FILES: Record<string, string> = {
  "claude-code": "CLAUDE.md",
  cursor: ".cursor/rules.md",
  copilot: ".github/copilot-instructions.md",
}

export async function generateCommand(options: GenerateOptions): Promise<void> {
  const rulesDir = options.dir ?? findRulesDir(process.cwd())

  if (!rulesDir) {
    console.error(chalk.red("No rules directory found."))
    console.error(chalk.dim("Run 'rulebound init' to create one."))
    process.exit(1)
  }

  let rules = loadLocalRules(rulesDir)

  if (rules.length === 0) {
    console.log(chalk.dim("No rules found."))
    return
  }

  // Task-aware filtering: only inject relevant rules
  if (options.task) {
    const projectConfig = getProjectConfig(process.cwd())
    rules = matchRulesByContext(rules, projectConfig, options.task)
  }

  const agents: AgentFormat[] =
    options.agent === "all" || !options.agent
      ? ["claude-code", "cursor", "copilot"]
      : [options.agent as AgentFormat]

  const outputDir = options.output ?? process.cwd()

  console.log()
  console.log(chalk.white("GENERATE AGENT CONFIGS"))
  console.log(chalk.dim(`Source: ${rulesDir} (${rules.length} rules)`))
  if (options.task) {
    console.log(chalk.dim(`Task filter: ${options.task}`))
  }
  console.log(chalk.dim("\u2500".repeat(50)))
  console.log()

  let count = 0
  for (const agent of agents) {
    if (agent === "all") continue

    const content = formatRulesForAgent(rules, agent)
    const fileName = AGENT_FILES[agent]
    if (!fileName) continue

    const filePath = resolve(outputDir, fileName)
    const dir = dirname(filePath)

    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true })
    }

    writeFileSync(filePath, content)
    console.log(`  ${chalk.white(fileName)} ${chalk.dim(`(${agent})`)}`)
    count++
  }

  console.log()
  console.log(chalk.white(`Generated ${count} config file${count === 1 ? "" : "s"}.`))
  console.log(chalk.dim("Commit these files so your AI agents pick them up."))
}
